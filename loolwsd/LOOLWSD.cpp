/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4; fill-column: 100 -*- */
/*
 * This file is part of the LibreOffice project.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 *
 * Parts of this file is covered by:

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.

 */

#include "config.h"

// This is the main source for the loolwsd program. LOOL uses several loolwsd processes: one main
// parent process that listens on the TCP port and accepts connections from LOOL clients, and a
// number of child processes, each which handles a viewing (editing) session for one document.

#include <errno.h>
#include <locale.h>
#include <unistd.h>

#include <sys/types.h>
#include <sys/wait.h>
#include <sys/prctl.h>

#include <ftw.h>
#include <time.h>
#include <utime.h>

#include <cassert>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <map>
#include <mutex>
#include <sstream>
#include <unordered_set>

#include <Poco/DOM/AutoPtr.h>
#include <Poco/DOM/DOMParser.h>
#include <Poco/DOM/DOMWriter.h>
#include <Poco/DOM/Document.h>
#include <Poco/DOM/Element.h>
#include <Poco/DOM/NodeList.h>
#include <Poco/Exception.h>
#include <Poco/File.h>
#include <Poco/FileStream.h>
#include <Poco/Net/ConsoleCertificateHandler.h>
#include <Poco/Net/Context.h>
#include <Poco/Net/HTMLForm.h>
#include <Poco/Net/HTTPClientSession.h>
#include <Poco/Net/HTTPRequest.h>
#include <Poco/Net/HTTPRequestHandler.h>
#include <Poco/Net/HTTPRequestHandlerFactory.h>
#include <Poco/Net/HTTPServer.h>
#include <Poco/Net/HTTPServerParams.h>
#include <Poco/Net/HTTPServerParams.h>
#include <Poco/Net/HTTPServerRequest.h>
#include <Poco/Net/HTTPServerResponse.h>
#include <Poco/Net/InvalidCertificateHandler.h>
#include <Poco/Net/KeyConsoleHandler.h>
#include <Poco/Net/MessageHeader.h>
#include <Poco/Net/Net.h>
#include <Poco/Net/NetException.h>
#include <Poco/Net/PartHandler.h>
#include <Poco/Net/PrivateKeyPassphraseHandler.h>
#include <Poco/Net/SSLManager.h>
#include <Poco/Net/SecureServerSocket.h>
#include <Poco/Net/ServerSocket.h>
#include <Poco/Net/SocketAddress.h>
#include <Poco/Net/WebSocket.h>
#include <Poco/Path.h>
#include <Poco/Process.h>
#include <Poco/SAX/InputSource.h>
#include <Poco/StreamCopier.h>
#include <Poco/StringTokenizer.h>
#include <Poco/TemporaryFile.h>
#include <Poco/ThreadLocal.h>
#include <Poco/ThreadPool.h>
#include <Poco/URI.h>
#include <Poco/Util/HelpFormatter.h>
#include <Poco/Util/Option.h>
#include <Poco/Util/OptionException.h>
#include <Poco/Util/OptionSet.h>
#include <Poco/Util/ServerApplication.h>

#include "Admin.hpp"
#include "Auth.hpp"
#include "ChildProcessSession.hpp"
#include "Common.hpp"
#include "FileServer.hpp"
#include "LOOLProtocol.hpp"
#include "LOOLSession.hpp"
#include "LOOLWSD.hpp"
#include "MasterProcessSession.hpp"
#include "QueueHandler.hpp"
#include "Util.hpp"

using namespace LOOLProtocol;

using Poco::Exception;
using Poco::File;
using Poco::FileOutputStream;
using Poco::IOException;
using Poco::Net::HTMLForm;
using Poco::Net::HTTPClientSession;
using Poco::Net::HTTPRequest;
using Poco::Net::HTTPRequestHandler;
using Poco::Net::HTTPRequestHandlerFactory;
using Poco::Net::HTTPResponse;
using Poco::Net::HTTPServer;
using Poco::Net::HTTPServerParams;
using Poco::Net::HTTPServerRequest;
using Poco::Net::HTTPServerResponse;
using Poco::Net::MessageHeader;
using Poco::Net::NameValueCollection;
using Poco::Net::PartHandler;
using Poco::Net::SecureServerSocket;
using Poco::Net::ServerSocket;
using Poco::Net::Socket;
using Poco::Net::SocketAddress;
using Poco::Net::WebSocket;
using Poco::Net::WebSocketException;
using Poco::Path;
using Poco::Process;
using Poco::ProcessHandle;
using Poco::Random;
using Poco::Runnable;
using Poco::StreamCopier;
using Poco::StringTokenizer;
using Poco::TemporaryFile;
using Poco::Thread;
using Poco::ThreadLocal;
using Poco::ThreadPool;
using Poco::Timespan;
using Poco::URI;
using Poco::Util::Application;
using Poco::Util::HelpFormatter;
using Poco::Util::IncompatibleOptionsException;
using Poco::Util::MissingOptionException;
using Poco::Util::Option;
using Poco::Util::OptionSet;
using Poco::Util::ServerApplication;
using Poco::XML::AutoPtr;
using Poco::XML::DOMParser;
using Poco::XML::DOMWriter;
using Poco::XML::Element;
using Poco::XML::InputSource;
using Poco::XML::Node;
using Poco::XML::NodeList;

static std::map<std::string, std::shared_ptr<DocumentBroker>> docBrokers;
static std::mutex docBrokersMutex;

static std::unordered_set<std::shared_ptr<MasterProcessSession>> sessions;
static std::mutex sessionsMutex;

/// Handles the filename part of the convert-to POST request payload.
class ConvertToPartHandler : public PartHandler
{
    std::string& _filename;
public:
    ConvertToPartHandler(std::string& filename)
        : _filename(filename)
    {
    }

    virtual void handlePart(const MessageHeader& header, std::istream& stream) override
    {
        // Extract filename and put it to a temporary directory.
        std::string disp;
        NameValueCollection params;
        if (header.has("Content-Disposition"))
        {
            std::string cd = header.get("Content-Disposition");
            MessageHeader::splitParameters(cd, disp, params);
        }

        if (!params.has("filename"))
            return;

        Path tempPath = Path::forDirectory(TemporaryFile().tempName() + Path::separator());
        File(tempPath).createDirectories();
        tempPath.setFileName(params.get("filename"));
        _filename = tempPath.toString();

        // Copy the stream to _filename.
        std::ofstream fileStream;
        fileStream.open(_filename);
        StreamCopier::copyStream(stream, fileStream);
        fileStream.close();
    }
};

// Synchronously process WebSocket requests and dispatch to handler.
// Handler returns false to end.
void SocketProcessor(std::shared_ptr<WebSocket> ws,
                     HTTPServerResponse& response,
                     std::function<bool(const char* data, const int size, const bool singleLine)> handler)
{
    Log::info("Starting Socket Processor.");

    const Timespan waitTime(POLL_TIMEOUT_MS * 1000);
    try
    {
        int flags = 0;
        int n = 0;
        ws->setReceiveTimeout(0);
        do
        {
            char buffer[200000]; //FIXME: Dynamic?

            if (ws->poll(waitTime, Socket::SELECT_READ))
            {
                n = ws->receiveFrame(buffer, sizeof(buffer), flags);

                if ((flags & WebSocket::FRAME_OP_BITMASK) == WebSocket::FRAME_OP_PING)
                {
                    // Echo back the ping payload as pong.
                    // Technically, we should send back a PONG control frame.
                    // However Firefox (probably) or Node.js (possibly) doesn't
                    // like that and closes the socket when we do.
                    // Echoing the payload as a normal frame works with Firefox.
                    ws->sendFrame(buffer, n /*, WebSocket::FRAME_OP_PONG*/);
                }
                else if ((flags & WebSocket::FRAME_OP_BITMASK) == WebSocket::FRAME_OP_PONG)
                {
                    // In case we do send pings in the future.
                }
                else if (n <= 0)
                {
                    // Connection closed.
                    Log::warn() << "Received " << n
                                << " bytes. Connection closed. Flags: "
                                << std::hex << flags << Log::end;
                    break;
                }
                else if ((flags & WebSocket::FRAME_OP_BITMASK) != WebSocket::FRAME_OP_CLOSE)
                {
                    assert(n > 0);
                    const std::string firstLine = getFirstLine(buffer, n);
                    StringTokenizer tokens(firstLine, " ", StringTokenizer::TOK_IGNORE_EMPTY | StringTokenizer::TOK_TRIM);
                    int size;

                    if (firstLine == "eof")
                    {
                        Log::info("Received EOF. Finishing.");
                        break;
                    }

                    if ((flags & WebSocket::FrameFlags::FRAME_FLAG_FIN) != WebSocket::FrameFlags::FRAME_FLAG_FIN)
                    {
                        // One WS message split into multiple frames.
                        std::vector<char> message(buffer, buffer + n);
                        while (true)
                        {
                            n = ws->receiveFrame(buffer, sizeof(buffer), flags);

                            if (n <= 0 || (flags & WebSocket::FRAME_OP_BITMASK) == WebSocket::FRAME_OP_CLOSE)
                                break;

                            message.insert(message.end(), buffer, buffer + n);
                            if ((flags & WebSocket::FrameFlags::FRAME_FLAG_FIN) == WebSocket::FrameFlags::FRAME_FLAG_FIN)
                            {
                                // No more frames: invoke the handler. Assume
                                // for now that this is always a multi-line
                                // message.
                                handler(message.data(), message.size(), false);
                                break;
                            }
                        }
                    }
                    else if (tokens.count() == 2 &&
                             tokens[0] == "nextmessage:" && getTokenInteger(tokens[1], "size", size) && size > 0)
                    {
                        // Check if it is a "nextmessage:" and in that case read the large
                        // follow-up message separately, and handle that only.

                        char largeBuffer[size];     //FIXME: Security risk! Flooding may segfault us.

                        n = ws->receiveFrame(largeBuffer, size, flags);
                        if (n > 0 && (flags & WebSocket::FRAME_OP_BITMASK) != WebSocket::FRAME_OP_CLOSE && !handler(largeBuffer, n, false))
                        {
                            Log::info("Socket handler flagged for finishing.");
                            break;
                        }
                    }
                    else if (firstLine.size() == static_cast<std::string::size_type>(n))
                    {
                        handler(firstLine.c_str(), firstLine.size(), true);
                    }
                    else if (!handler(buffer, n, false))
                    {
                        Log::info("Socket handler flagged for finishing.");
                        break;
                    }
                }
            }
        }
        while (!TerminationFlag &&
               (flags & WebSocket::FRAME_OP_BITMASK) != WebSocket::FRAME_OP_CLOSE);
        Log::debug() << "Finishing SocketProcessor. TerminationFlag: " << TerminationFlag
                     << ", payload size: " << n
                     << ", flags: " << std::hex << flags << Log::end;
    }
    catch (const WebSocketException& exc)
    {
        Log::error("SocketProcessor: WebSocketException: " + exc.message());
        switch (exc.code())
        {
        case WebSocket::WS_ERR_HANDSHAKE_UNSUPPORTED_VERSION:
            response.set("Sec-WebSocket-Version", WebSocket::WEBSOCKET_VERSION);
            // fallthrough
        case WebSocket::WS_ERR_NO_HANDSHAKE:
        case WebSocket::WS_ERR_HANDSHAKE_NO_VERSION:
        case WebSocket::WS_ERR_HANDSHAKE_NO_KEY:
            response.setStatusAndReason(HTTPResponse::HTTP_BAD_REQUEST);
            response.setContentLength(0);
            response.send();
            break;
        }
    }

    Log::info("Finished Socket Processor.");
}


/// Handle a public connection from a client.
class ClientRequestHandler: public HTTPRequestHandler
{
private:

    void handlePostRequest(HTTPServerRequest& request, HTTPServerResponse& response, const std::string& id)
    {
        Log::info("Post request: [" + request.getURI() + "]");
        StringTokenizer tokens(request.getURI(), "/?");
        if (tokens.count() >= 2 && tokens[1] == "convert-to")
        {
            std::string fromPath;
            ConvertToPartHandler handler(fromPath);
            HTMLForm form(request, request.stream(), handler);
            const std::string format = (form.has("format") ? form.get("format") : "");

            bool sent = false;
            if (!fromPath.empty())
            {
                if (!format.empty())
                {
                    Log::info("Conversion request for URI [" + fromPath + "].");
                    auto uriPublic = DocumentBroker::sanitizeURI(fromPath);
                    const auto docKey = DocumentBroker::getDocKey(uriPublic);
                    auto docBroker = std::make_shared<DocumentBroker>(uriPublic, docKey, LOOLWSD::ChildRoot);

                    // This lock could become a bottleneck.
                    // In that case, we can use a pool and index by publicPath.
                    std::unique_lock<std::mutex> lock(docBrokersMutex);

                    Log::debug("New DocumentBroker for docKey [" + docKey + "].");
                    docBrokers.emplace(docKey, docBroker);

                    // Load the document.
                    std::shared_ptr<WebSocket> ws;
                    const LOOLSession::Kind kind = LOOLSession::Kind::ToClient;
                    auto session = std::make_shared<MasterProcessSession>(id, kind, ws, docBroker);
                    docBroker->incSessions();
                    lock.unlock();

                    std::string encodedFrom;
                    URI::encode(docBroker->getPublicUri().getPath(), "", encodedFrom);
                    const std::string load = "load url=" + encodedFrom;
                    session->handleInput(load.data(), load.size());

                    // Convert it to the requested format.
                    Path toPath(docBroker->getPublicUri().getPath());
                    toPath.setExtension(format);
                    const std::string toJailURL = "file://" + JailedDocumentRoot + toPath.getFileName();
                    std::string encodedTo;
                    URI::encode(toJailURL, "", encodedTo);
                    std::string saveas = "saveas url=" + encodedTo + " format=" + format + " options=";
                    session->handleInput(saveas.data(), saveas.size());

                    // Send it back to the client.
                    Poco::URI resultURL(session->getSaveAs());
                    if (!resultURL.getPath().empty())
                    {
                        const std::string mimeType = "application/octet-stream";
                        response.sendFile(resultURL.getPath(), mimeType);
                        sent = true;
                    }

                    lock.lock();
                    if (docBroker->decSessions() == 0)
                    {
                        Log::debug("Removing DocumentBroker for docKey [" + docKey + "].");
                        docBrokers.erase(docKey);
                    }
                }

                // Clean up the temporary directory the HTMLForm ctor created.
                Path tempDirectory(fromPath);
                tempDirectory.setFileName("");
                Util::removeFile(tempDirectory, /*recursive=*/true);
            }

            if (!sent)
            {
                response.setStatus(HTTPResponse::HTTP_BAD_REQUEST);
                response.setContentLength(0);
                response.send();
            }
        }
        else if (tokens.count() >= 2 && tokens[1] == "insertfile")
        {
            Log::info("Insert file request.");
            response.set("Access-Control-Allow-Origin", "*");
            response.set("Access-Control-Allow-Methods", "GET, POST, OPTIONS");
            response.set("Access-Control-Allow-Headers", "Origin, X-Requested-With, Content-Type, Accept");

            std::string tmpPath;
            ConvertToPartHandler handler(tmpPath);
            HTMLForm form(request, request.stream(), handler);

            bool goodRequest = form.has("childid") && form.has("name");
            std::string formChildid(form.get("childid"));
            std::string formName(form.get("name"));

            // protect against attempts to inject something funny here
            if (goodRequest && formChildid.find('/') != std::string::npos && formName.find('/') != std::string::npos)
                goodRequest = false;

            if (goodRequest)
            {
                try
                {
                    Log::info() << "Perform insertfile: " << formChildid << ", " << formName << Log::end;
                    const std::string dirPath = LOOLWSD::ChildRoot + formChildid
                                              + JailedDocumentRoot + "insertfile";
                    File(dirPath).createDirectories();
                    std::string fileName = dirPath + Path::separator() + form.get("name");
                    File(tmpPath).moveTo(fileName);

                    response.setStatus(HTTPResponse::HTTP_OK);
                    response.send();
                }
                catch (const IOException& exc)
                {
                    Log::info() << "ClientRequestHandler::handlePostRequest: IOException: " << exc.message() << Log::end;
                    response.setStatus(HTTPResponse::HTTP_BAD_REQUEST);
                    response.send();
                }
            }
            else
            {
                response.setStatus(HTTPResponse::HTTP_BAD_REQUEST);
                response.send();
            }
        }
        else if (tokens.count() >= 4)
        {
            Log::info("File download request.");
            // The user might request a file to download
            const std::string dirPath = LOOLWSD::ChildRoot + tokens[1]
                                      + JailedDocumentRoot + tokens[2];
            std::string fileName;
            URI::decode(tokens[3], fileName);
            const std::string filePath = dirPath + Path::separator() + fileName;
            Log::info("HTTP request for: " + filePath);
            File file(filePath);
            if (file.exists())
            {
                response.set("Access-Control-Allow-Origin", "*");
                HTMLForm form(request);
                std::string mimeType = "application/octet-stream";
                if (form.has("mime_type"))
                    mimeType = form.get("mime_type");
                response.sendFile(filePath, mimeType);
                Util::removeFile(dirPath, true);
            }
            else
            {
                response.setStatus(HTTPResponse::HTTP_NOT_FOUND);
                response.setContentLength(0);
                response.send();
            }
        }
        else
        {
            Log::info("Bad request.");
            response.setStatus(HTTPResponse::HTTP_BAD_REQUEST);
            response.setContentLength(0);
            response.send();
        }
    }

    bool authenticate(HTTPServerRequest& request, HTTPServerResponse& response, const std::string& id)
    {
        (void)response;
        Log::info("Authenticating Get request processor for session [" + id + "].");
        std::string token;
        for (auto& pair : URI(request.getURI()).getQueryParameters())
        {
            if (pair.first == "token")
            {
                token = pair.second;
                break;
            }
        }

        //TODO:
        //AuthAgent.verify(token);
        return true;
    }

    void handleGetRequest(HTTPServerRequest& request, HTTPServerResponse& response, const std::string& id)
    {
        Log::info("Starting GET request handler for session [" + id + "].");

        //TODO: Authenticate the caller.
        // authenticate(request, response);
        // NameValueCollection cookies;
        // request.getCookies(cookies);
        // Log::info("Cookie: " + cookies.get("PHPSESSID", ""));

        // Remove the leading '/' in the GET URL.
        std::string uri = request.getURI();
        if (uri.size() > 0 && uri[0] == '/')
        {
            uri.erase(0, 1);
        }

        const auto uriPublic = DocumentBroker::sanitizeURI(uri);
        const auto docKey = DocumentBroker::getDocKey(uriPublic);
        std::shared_ptr<DocumentBroker> docBroker;
        // This lock could become a bottleneck.
        // In that case, we can use a pool and index by publicPath.
        std::unique_lock<std::mutex> docBrokersLock(docBrokersMutex);

        // Lookup this document.
        auto it = docBrokers.find(docKey);
        if (it != docBrokers.end())
        {
            // Get the DocumentBroker from the Cache.
            Log::debug("Found DocumentBroker for docKey [" + docKey + "].");
            docBroker = it->second;
            assert(docBroker);
        }
        else
        {
            // Set one we just created.
            Log::debug("New DocumentBroker for docKey [" + docKey + "].");
            docBroker = std::make_shared<DocumentBroker>(uriPublic, docKey, LOOLWSD::ChildRoot);
            docBrokers.emplace(docKey, docBroker);
        }

        // Validate the URI and Storage before moving on.
        docBroker->validate(uriPublic);
        Log::debug("Validated [" + uriPublic.toString() + "].");

        auto ws = std::make_shared<WebSocket>(request, response);
        auto session = std::make_shared<MasterProcessSession>(id, LOOLSession::Kind::ToClient, ws, docBroker);
        docBroker->incSessions();
        docBrokersLock.unlock();

        std::unique_lock<std::mutex> sessionsLock(sessionsMutex);
        sessions.insert(session);
        Log::debug("sessions++: " + std::to_string(sessions.size()));
        sessionsLock.unlock();

        // Request a kit process for this doc.
        const std::string aMessage = "request " + id + " " + docKey + "\r\n";
        Log::debug("MasterToBroker: " + aMessage.substr(0, aMessage.length() - 2));
        Util::writeFIFO(LOOLWSD::BrokerWritePipe, aMessage);

        // For ToClient sessions, we store incoming messages in a queue and have a separate
        // thread that handles them. This is so that we can empty the queue when we get a
        // "canceltiles" message.
        BasicTileQueue queue;
        QueueHandler handler(queue, session, "wsd_queue_" + session->getId());

        Thread queueHandlerThread;
        queueHandlerThread.start(handler);
        bool normalShutdown = false;

        SocketProcessor(ws, response, [&session, &queue, &normalShutdown](const char* data, const int size, const bool singleLine)
            {
                // FIXME: There is a race here when a request A gets in the queue and
                // is processed _after_ a later request B, because B gets processed
                // synchronously and A is waiting in the queue thread.
                // The fix is to push everything into the queue
                // (i.e. change MessageQueue to vector<char>).
                const std::string firstLine = getFirstLine(data, size);
                time(&session->lastMessageTime);
                if (singleLine || firstLine.find("paste") == 0)
                {
                    if (firstLine.compare(0, 10, "disconnect") == 0) // starts with "disconnect"
                    {
                        normalShutdown = true;
                        return true;
                    }

                    queue.put(std::string(data, size));
                    return true;
                }
                else
                {
                    return session->handleInput(data, size);
                }
            });

        if (docBroker->getSessionsCount() == 1 && !normalShutdown)
        {
            //TODO: This really should move to the kit, where it
            // knows if a doc is unsaved, and if other views are open.
            Log::info("Non-deliberate shutdown of the last session, saving the document before tearing down.");
            queue.put("uno .uno:Save");
        }
        else
        {
            Log::info("Clearing the queue.");
            queue.clear();
        }

        sessionsLock.lock();
        sessions.erase(session);
        Log::debug("sessions--: " + std::to_string(sessions.size()));
        sessionsLock.unlock();

        Log::info("Finishing GET request handler for session [" + id + "]. Joining the queue.");
        queue.put("eof");
        queueHandlerThread.join();

        docBrokersLock.lock();
        if (docBroker->decSessions() == 0)
        {
            Log::debug("Removing DocumentBroker for docKey [" + docKey + "].");
            docBrokers.erase(docKey);
        }
    }

    void handleGetDiscovery(HTTPServerRequest& request, HTTPServerResponse& response)
    {
        DOMParser parser;
        DOMWriter writer;
        URI uri("http", request.getHost(), request.getURI());

        const std::string discoveryPath = Path(Application::instance().commandPath()).parent().toString() + "discovery.xml";
        const std::string mediaType = "text/xml";
        const std::string action = "action";
        const std::string urlsrc = "urlsrc";
        const std::string uriValue = "http://" + uri.getHost() + LOLEAFLET_PATH;

        InputSource inputSrc(discoveryPath);
        AutoPtr<Poco::XML::Document> docXML = parser.parse(&inputSrc);
        AutoPtr<NodeList> listNodes = docXML->getElementsByTagName(action);

        for (unsigned long it = 0; it < listNodes->length(); it++)
        {
            static_cast<Element*>(listNodes->item(it))->setAttribute(urlsrc, uriValue);
        }

        std::ostringstream ostrXML;
        writer.writeNode(ostrXML, docXML);

        response.set("User-Agent", "LOOLWSD WOPI Agent");
        response.setContentLength(ostrXML.str().length());
        response.setContentType(mediaType);
        response.setChunkedTransferEncoding(false);

        std::ostream& ostr = response.send();
        ostr << ostrXML.str();
    }

public:

    void handleRequest(HTTPServerRequest& request, HTTPServerResponse& response) override
    {
        const auto id = LOOLWSD::GenSessionId();
        const std::string thread_name = "client_ws_" + id;

        if (prctl(PR_SET_NAME, reinterpret_cast<unsigned long>(thread_name.c_str()), 0, 0, 0) != 0)
            Log::error("Cannot set thread name to " + thread_name + ".");

        Log::debug("Thread [" + thread_name + "] started.");

        try
        {
            if (request.getMethod() == HTTPRequest::HTTP_GET && request.getURI() == "/hosting/discovery")
            {
                // http://server/hosting/discovery
                handleGetDiscovery(request, response);
            }
            else if (!(request.find("Upgrade") != request.end() && Poco::icompare(request["Upgrade"], "websocket") == 0))
            {
                handlePostRequest(request, response, id);
            }
            else
            {
                //authenticate(request, response, id);
                handleGetRequest(request, response, id);
            }
        }
        catch (const Exception& exc)
        {
            Log::error() << "ClientRequestHandler::handleRequest: Exception: " << exc.displayText()
                         << (exc.nested() ? " (" + exc.nested()->displayText() + ")" : "")
                         << Log::end;
        }
        catch (const std::exception& exc)
        {
            Log::error(std::string("ClientRequestHandler::handleRequest: Exception: ") + exc.what());
        }
        catch (...)
        {
            Log::error("ClientRequestHandler::handleRequest: Unexpected exception");
        }

        Log::debug("Thread [" + thread_name + "] finished.");
    }
};

/// Handle requests from prisoners (internal).
class PrisonerRequestHandler: public HTTPRequestHandler
{
public:

    void handleRequest(HTTPServerRequest& request, HTTPServerResponse& response) override
    {
        assert(request.serverAddress().port() == MASTER_PORT_NUMBER);
        assert(request.getURI().find(CHILD_URI) == 0);

        std::string thread_name = "prison_ws_";
        try
        {
            const auto params = Poco::URI(request.getURI()).getQueryParameters();
            std::string sessionId;
            std::string jailId;
            std::string docKey;
            for (const auto& param : params)
            {
                if (param.first == "sessionId")
                {
                    sessionId = param.second;
                }
                else if (param.first == "jailId")
                {
                    jailId = param.second;
                }
                else if (param.first == "docKey")
                {
                    docKey = param.second;
                }
            }

            thread_name += sessionId;
            if (prctl(PR_SET_NAME, reinterpret_cast<unsigned long>(thread_name.c_str()), 0, 0, 0) != 0)
                Log::error("Cannot set thread name to " + thread_name + ".");

            Log::debug("Thread [" + thread_name + "] started.");

            Log::debug("Child socket for SessionId: " + sessionId + ", jailId: " + jailId +
                       ", docKey: " + docKey + " connected.");

            std::shared_ptr<DocumentBroker> docBroker;
            {
                // This lock could become a bottleneck.
                // In that case, we can use a pool and index by publicPath.
                std::unique_lock<std::mutex> lock(docBrokersMutex);

                // Lookup this document.
                auto it = docBrokers.find(docKey);
                if (it != docBrokers.end())
                {
                    // Get the DocumentBroker from the Cache.
                    docBroker = it->second;
                    assert(docBroker);
                }
                else
                {
                    // The client closed before we started,
                    // or some early failure happened.
                    Log::error("Failed to find DocumentBroker for docKey [" + docKey +
                               "] while handling child connection for session [" + sessionId + "].");
                    throw std::runtime_error("Invalid docKey.");
                }
            }

            docBroker->load(jailId);

            auto ws = std::make_shared<WebSocket>(request, response);
            auto session = std::make_shared<MasterProcessSession>(sessionId, LOOLSession::Kind::ToPrisoner, ws, docBroker);

            std::unique_lock<std::mutex> lock(MasterProcessSession::AvailableChildSessionMutex);
            MasterProcessSession::AvailableChildSessions.emplace(sessionId, session);

            Log::info() << " mapped " << session << " jailId=" << jailId << ", id=" << sessionId
                        << " into _availableChildSessions, size=" << MasterProcessSession::AvailableChildSessions.size() << Log::end;

            lock.unlock();
            MasterProcessSession::AvailableChildSessionCV.notify_one();

            SocketProcessor(ws, response, [&session](const char* data, const int size, bool)
                {
                    return session->handleInput(data, size);
                });
        }
        catch (const Exception& exc)
        {
            Log::error() << "PrisonerRequestHandler::handleRequest: Exception: " << exc.displayText()
                         << (exc.nested() ? " (" + exc.nested()->displayText() + ")" : "")
                         << Log::end;
        }
        catch (const std::exception& exc)
        {
            Log::error(std::string("PrisonerRequestHandler::handleRequest: Exception: ") + exc.what());
        }
        catch (...)
        {
            Log::error("PrisonerRequestHandler::handleRequest: Unexpected exception");
        }

        Log::debug("Thread [" + thread_name + "] finished.");
    }
};

class ClientRequestHandlerFactory: public HTTPRequestHandlerFactory
{
public:
    ClientRequestHandlerFactory(Admin& admin, FileServer& fileServer)
        : _admin(admin),
          _fileServer(fileServer)
        { }

    HTTPRequestHandler* createRequestHandler(const HTTPServerRequest& request) override
    {
        if (prctl(PR_SET_NAME, reinterpret_cast<unsigned long>("request_handler"), 0, 0, 0) != 0)
            Log::error("Cannot set thread name to request_handler.");

        auto logger = Log::info();
        logger << "Request from " << request.clientAddress().toString() << ": "
               << request.getMethod() << " " << request.getURI() << " "
               << request.getVersion();

        for (HTTPServerRequest::ConstIterator it = request.begin(); it != request.end(); ++it)
        {
            logger << " / " << it->first << ": " << it->second;
        }

        logger << Log::end;

        // Routing
        // FIXME: Some browsers (all?) hit for /favicon.ico. Create a nice favicon and add to routes
        Poco::URI requestUri(request.getURI());
        std::vector<std::string> reqPathSegs;
        requestUri.getPathSegments(reqPathSegs);
        HTTPRequestHandler* requestHandler;

        // File server
        if (reqPathSegs.size() >= 1 && reqPathSegs[0] == "loleaflet")
        {
            requestHandler = _fileServer.createRequestHandler();
        }
        // Admin WebSocket Connections
        else if (reqPathSegs.size() >= 1 && reqPathSegs[0] == "adminws")
        {
            requestHandler = _admin.createRequestHandler();
        }
        // Client post and websocket connections
        else
        {
            requestHandler = new ClientRequestHandler();
        }

        return requestHandler;
    }

private:
    Admin& _admin;
    FileServer& _fileServer;
};

class PrisonerRequestHandlerFactory: public HTTPRequestHandlerFactory
{
public:
    HTTPRequestHandler* createRequestHandler(const HTTPServerRequest& request) override
    {
        if (prctl(PR_SET_NAME, reinterpret_cast<unsigned long>("request_handler"), 0, 0, 0) != 0)
            Log::error("Cannot set thread name to request_handler.");

        auto logger = Log::info();
        logger << "Request from " << request.clientAddress().toString() << ": "
               << request.getMethod() << " " << request.getURI() << " "
               << request.getVersion();

        for (HTTPServerRequest::ConstIterator it = request.begin(); it != request.end(); ++it)
        {
            logger << " / " << it->first << ": " << it->second;
        }

        logger << Log::end;
        return new PrisonerRequestHandler();
    }
};

class TestOutput : public Runnable
{
public:
    TestOutput(WebSocket& ws) :
        _ws(ws)
    {
    }

    void run() override
    {
        int flags;
        int n;
        _ws.setReceiveTimeout(0);
        try
        {
            do
            {
                char buffer[200000];
                n = _ws.receiveFrame(buffer, sizeof(buffer), flags);
                if (n > 0 && (flags & WebSocket::FRAME_OP_BITMASK) != WebSocket::FRAME_OP_CLOSE)
                {
                    Log::trace() << "Client got " << n << " bytes: "
                                 << getAbbreviatedMessage(buffer, n) << Log::end;
                }
            }
            while (n > 0 && (flags & WebSocket::FRAME_OP_BITMASK) != WebSocket::FRAME_OP_CLOSE);
        }
        catch (const WebSocketException& exc)
        {
            Log::error("TestOutput::run(), WebSocketException: " + exc.message());
            _ws.close();
        }
    }

private:
    WebSocket& _ws;
};

class TestInput : public Runnable
{
public:
    TestInput(ServerApplication& main, ServerSocket& svs, HTTPServer& srv) :
        _main(main),
        _svs(svs),
        _srv(srv)
    {
    }

    void run() override
    {
        HTTPClientSession cs("127.0.0.1", _svs.address().port());
        HTTPRequest request(HTTPRequest::HTTP_GET, "/ws");
        HTTPResponse response;
        WebSocket ws(cs, request, response);

        Thread thread;
        TestOutput output(ws);
        thread.start(output);

        if (isatty(0))
        {
            std::cout << std::endl;
            std::cout << "Enter LOOL WS requests, one per line. Enter EOF to finish." << std::endl;
        }

        while (!std::cin.eof())
        {
            std::string line;
            std::getline(std::cin, line);
            ws.sendFrame(line.c_str(), line.size());
        }
        thread.join();
        _srv.stopAll();
        _main.terminate();
    }

private:
    ServerApplication& _main;
    ServerSocket& _svs;
    HTTPServer& _srv;
};

std::atomic<unsigned> LOOLWSD::NextSessionId;
int LOOLWSD::BrokerWritePipe = -1;
std::string LOOLWSD::Cache = LOOLWSD_CACHEDIR;
std::string LOOLWSD::SysTemplate;
std::string LOOLWSD::LoTemplate;
std::string LOOLWSD::ChildRoot;
std::string LOOLWSD::LoSubPath = "lo";
std::string LOOLWSD::FileServerRoot;

int LOOLWSD::NumPreSpawnedChildren = 10;
bool LOOLWSD::DoTest = false;
const std::string LOOLWSD::PIDLOG = "/tmp/loolwsd.pid";
const std::string LOOLWSD::FIFO_PATH = "pipe";
const std::string LOOLWSD::FIFO_LOOLWSD = "loolwsdfifo";

// Demo Site Verification URL.
static const std::string DemoAuthVerificationUrl = "http://ec2-54-216-97-44.eu-west-1.compute.amazonaws.com/cloudsuite-demo/verify.php?type&token=";

LOOLWSD::LOOLWSD()
{
}

LOOLWSD::~LOOLWSD()
{
}

void LOOLWSD::initialize(Application& self)
{
    // load default configuration files, if present
    loadConfiguration();

    ServerApplication::initialize(self);
}

void LOOLWSD::uninitialize()
{
    ServerApplication::uninitialize();
}

void LOOLWSD::defineOptions(OptionSet& optionSet)
{
    ServerApplication::defineOptions(optionSet);

    optionSet.addOption(Option("help", "", "Display help information on command line arguments.")
                        .required(false)
                        .repeatable(false));

    optionSet.addOption(Option("version", "", "Display version information.")
                        .required(false)
                        .repeatable(false));

    optionSet.addOption(Option("port", "", "Port number to listen to (default: " + std::to_string(DEFAULT_CLIENT_PORT_NUMBER) + "),"
                             " must not be " + std::to_string(MASTER_PORT_NUMBER) + ".")
                        .required(false)
                        .repeatable(false)
                        .argument("port number"));

    optionSet.addOption(Option("cache", "", "Path to a directory where to keep the persistent tile cache (default: " + std::string(LOOLWSD_CACHEDIR) + ").")
                        .required(false)
                        .repeatable(false)
                        .argument("directory"));

    optionSet.addOption(Option("systemplate", "", "Path to a template tree with shared libraries etc to be used as source for chroot jails for child processes.")
                        .required(false)
                        .repeatable(false)
                        .argument("directory"));

    optionSet.addOption(Option("lotemplate", "", "Path to a LibreOffice installation tree to be copied (linked) into the jails for child processes. Should be on the same file system as systemplate.")
                        .required(false)
                        .repeatable(false)
                        .argument("directory"));

    optionSet.addOption(Option("childroot", "", "Path to the directory under which the chroot jails for the child processes will be created. Should be on the same file system as systemplate and lotemplate.")
                        .required(false)
                        .repeatable(false)
                        .argument("directory"));

    optionSet.addOption(Option("losubpath", "", "Relative path where the LibreOffice installation will be copied inside a jail (default: '" + LoSubPath + "').")
                        .required(false)
                        .repeatable(false)
                        .argument("relative path"));

    optionSet.addOption(Option("fileserverroot", "", "Path to the directory that should be considered root for the file server (default: '../loleaflet/').")
                        .required(false)
                        .repeatable(false)
                        .argument("directory"));

    optionSet.addOption(Option("numprespawns", "", "Number of child processes to keep started in advance and waiting for new clients.")
                        .required(false)
                        .repeatable(false)
                        .argument("number"));

    optionSet.addOption(Option("test", "", "Interactive testing.")
                        .required(false)
                        .repeatable(false));
}

void LOOLWSD::handleOption(const std::string& optionName, const std::string& value)
{
    ServerApplication::handleOption(optionName, value);

    if (optionName == "help")
    {
        displayHelp();
        std::exit(Application::EXIT_OK);
    }
    else if (optionName == "version")
    {
        displayVersion();
        std::exit(Application::EXIT_OK);
    }
    else if (optionName == "port")
        ClientPortNumber = std::stoi(value);
    else if (optionName == "cache")
        Cache = value;
    else if (optionName == "systemplate")
        SysTemplate = value;
    else if (optionName == "lotemplate")
        LoTemplate = value;
    else if (optionName == "childroot")
        ChildRoot = value;
    else if (optionName == "losubpath")
        LoSubPath = value;
    else if (optionName == "fileserverroot")
        FileServerRoot = value;
    else if (optionName == "numprespawns")
        NumPreSpawnedChildren = std::stoi(value);
    else if (optionName == "test")
        LOOLWSD::DoTest = true;
}

void LOOLWSD::displayHelp()
{
    HelpFormatter helpFormatter(options());
    helpFormatter.setCommand(commandName());
    helpFormatter.setUsage("OPTIONS");
    helpFormatter.setHeader("LibreOffice On-Line WebSocket server.");
    helpFormatter.format(std::cout);
}

void LOOLWSD::displayVersion()
{
    std::cout << LOOLWSD_VERSION << std::endl;
}

Process::PID LOOLWSD::createBroker()
{
    Process::Args args;

    args.push_back("--losubpath=" + LOOLWSD::LoSubPath);
    args.push_back("--systemplate=" + SysTemplate);
    args.push_back("--lotemplate=" + LoTemplate);
    args.push_back("--childroot=" + ChildRoot);
    args.push_back("--numprespawns=" + std::to_string(NumPreSpawnedChildren));
    args.push_back("--clientport=" + std::to_string(ClientPortNumber));

    const std::string brokerPath = Path(Application::instance().commandPath()).parent().toString() + "loolbroker";

    Log::info("Launching Broker #1: " + brokerPath + " " +
              Poco::cat(std::string(" "), args.begin(), args.end()));

    ProcessHandle child = Process::launch(brokerPath, args);

    return child.id();
}

int LOOLWSD::main(const std::vector<std::string>& /*args*/)
{
    Log::initialize("wsd");

    if (geteuid() == 0)
    {
        Log::error("Don't run this as root");
        return Application::EXIT_USAGE;
    }

    Poco::Crypto::initializeCrypto();

    // SSL initialize
    Poco::Net::initializeSSL();
    Poco::Net::Context::Params sslParams;
    sslParams.certificateFile = Path(Application::instance().commandPath()).parent().toString() + SSL_CERT_FILE;
    sslParams.privateKeyFile = Path(Application::instance().commandPath()).parent().toString() + SSL_KEY_FILE;
    // Don't ask clients for certificate
    sslParams.verificationMode = Poco::Net::Context::VERIFY_NONE;

    Poco::SharedPtr<Poco::Net::PrivateKeyPassphraseHandler> consoleHandler = new Poco::Net::KeyConsoleHandler(true);
    Poco::SharedPtr<Poco::Net::InvalidCertificateHandler> invalidCertHandler = new Poco::Net::ConsoleCertificateHandler(false);

    Poco::Net::Context::Ptr sslContext = new Poco::Net::Context(Poco::Net::Context::SERVER_USE, sslParams);
    Poco::Net::SSLManager::instance().initializeServer(consoleHandler, invalidCertHandler, sslContext);

    char *locale = setlocale(LC_ALL, nullptr);
    if (locale == nullptr || std::strcmp(locale, "C") == 0)
        setlocale(LC_ALL, "en_US.utf8");

    Util::setTerminationSignals();
    Util::setFatalSignals();

    if (access(Cache.c_str(), R_OK | W_OK | X_OK) != 0)
    {
        Log::error("Unable to access cache [" + Cache +
                   "] please make sure it exists, and has write permission for this user.");
        return Application::EXIT_SOFTWARE;
    }

    // We use the same option set for both parent and child loolwsd,
    // so must check options required in the parent (but not in the
    // child) separately now. Also check for options that are
    // meaningless for the parent.
    if (SysTemplate.empty())
        throw MissingOptionException("systemplate");
    if (LoTemplate.empty())
        throw MissingOptionException("lotemplate");

    if (ChildRoot.empty())
        throw MissingOptionException("childroot");
    else if (ChildRoot[ChildRoot.size() - 1] != Path::separator())
        ChildRoot += Path::separator();

    if (FileServerRoot.empty())
        FileServerRoot = Path(Application::instance().commandPath()).parent().parent().toString();

    if (ClientPortNumber == MASTER_PORT_NUMBER)
        throw IncompatibleOptionsException("port");

    if (LOOLWSD::DoTest)
        NumPreSpawnedChildren = 1;

    // log pid information
    {
        FileOutputStream filePID(LOOLWSD::PIDLOG);
        if (filePID.good())
            filePID << Process::id();
    }

    const Path pipePath = Path::forDirectory(ChildRoot + Path::separator() + FIFO_PATH);
    if (!File(pipePath).exists() && !File(pipePath).createDirectory())
    {
        Log::error("Error: Failed to create pipe directory [" + pipePath.toString() + "].");
        return Application::EXIT_SOFTWARE;
    }

    const std::string pipeLoolwsd = Path(pipePath, FIFO_LOOLWSD).toString();
    if (mkfifo(pipeLoolwsd.c_str(), 0666) < 0 && errno != EEXIST)
    {
        Log::error("Error: Failed to create pipe FIFO [" + pipeLoolwsd + "].");
        return Application::EXIT_SOFTWARE;
    }

    // Open notify pipe
    int pipeFlags = O_RDONLY | O_NONBLOCK;
    int notifyPipe = -1;
    const std::string pipeNotify = Path(pipePath, FIFO_NOTIFY).toString();
    if (mkfifo(pipeNotify.c_str(), 0666) < 0 && errno != EEXIST)
    {
        Log::error("Error: Failed to create pipe FIFO [" + FIFO_NOTIFY + "].");
        exit(Application::EXIT_SOFTWARE);
    }

    if ((notifyPipe = open(pipeNotify.c_str(), pipeFlags) ) < 0)
    {
        Log::error("Error: pipe opened for reading.");
        exit(Application::EXIT_SOFTWARE);
    }

    if ((pipeFlags = fcntl(notifyPipe, F_GETFL, 0)) < 0)
    {
        Log::error("Error: failed to get pipe flags [" + FIFO_NOTIFY + "].");
        exit(Application::EXIT_SOFTWARE);
    }

    pipeFlags &= ~O_NONBLOCK;
    if (fcntl(notifyPipe, F_SETFL, pipeFlags) < 0)
    {
        Log::error("Error: failed to set pipe flags [" + FIFO_NOTIFY + "].");
        exit(Application::EXIT_SOFTWARE);
    }

    const Process::PID brokerPid = createBroker();
    if (brokerPid < 0)
    {
        Log::error("Failed to spawn loolBroker.");
        return Application::EXIT_SOFTWARE;
    }

    // Init the Admin manager
    Admin admin(brokerPid, notifyPipe);
    // Init the file server
    FileServer fileServer;

    // Configure the Server.
    // Note: TCPServer internally uses the default
    // ThreadPool to dispatch connections.
    // The capacity of the default ThreadPool
    // is increased to match MaxThreads.
    // We must have sufficient available threads
    // in the default ThreadPool to dispatch
    // connections, otherwise we will deadlock.
    auto params1 = new HTTPServerParams();
    params1->setMaxThreads(MAX_SESSIONS);
    auto params2 = new HTTPServerParams();
    params2->setMaxThreads(MAX_SESSIONS);

    // Start a server listening on the port for clients
    SecureServerSocket svs(ClientPortNumber);
    ThreadPool threadPool(NumPreSpawnedChildren*6, MAX_SESSIONS * 2);
    HTTPServer srv(new ClientRequestHandlerFactory(admin, fileServer), threadPool, svs, params1);

    srv.start();

    // And one on the port for child processes
    SocketAddress addr2("127.0.0.1", MASTER_PORT_NUMBER);
    ServerSocket svs2(addr2);
    HTTPServer srv2(new PrisonerRequestHandlerFactory(), threadPool, svs2, params2);

    srv2.start();

    if ( (BrokerWritePipe = open(pipeLoolwsd.c_str(), O_WRONLY) ) < 0 )
    {
        Log::error("Error: failed to open pipe [" + pipeLoolwsd + "] write only.");
        return Application::EXIT_SOFTWARE;
    }

    threadPool.start(admin);

    TestInput input(*this, svs, srv);
    Thread inputThread;
    if (LOOLWSD::DoTest)
    {
        inputThread.start(input);
        waitForTerminationRequest();
    }

    time_t last30SecCheck = time(NULL);
    time_t lastFiveMinuteCheck = time(NULL);

    int status = 0;
    while (!TerminationFlag && !LOOLWSD::DoTest)
    {
        const pid_t pid = waitpid(brokerPid, &status, WUNTRACED | WNOHANG);
        if (pid > 0)
        {
            if (brokerPid == pid)
            {
                if (WIFEXITED(status))
                {
                    Log::info() << "Child process [" << pid << "] exited with code: "
                                << WEXITSTATUS(status) << "." << Log::end;

                    break;
                }
                else
                if (WIFSIGNALED(status))
                {
                    std::string fate = "died";
                    if (WCOREDUMP(status))
                        fate = "core-dumped";
                    Log::error() << "Child process [" << pid << "] " << fate
                                 << " with " << Util::signalName(WTERMSIG(status))
                                 << " signal: " << strsignal(WTERMSIG(status))
                                 << Log::end;

                    break;
                }
                else if (WIFSTOPPED(status))
                {
                    Log::info() << "Child process [" << pid << "] stopped with "
                                << Util::signalName(WSTOPSIG(status))
                                << " signal: " << strsignal(WTERMSIG(status))
                                << Log::end;
                }
                else if (WIFCONTINUED(status))
                {
                    Log::info() << "Child process [" << pid << "] resumed with SIGCONT."
                                << Log::end;
                }
                else
                {
                    Log::warn() << "Unknown status returned by waitpid: "
                                << std::hex << status << "." << Log::end;
                }
            }
            else
            {
                Log::error("An unknown child process died, pid: " + std::to_string(pid));
            }
        }
        else if (pid < 0)
        {
            Log::error("Error: waitpid failed.");
            // No child processes
            if (errno == ECHILD)
            {
                TerminationFlag = true;
                continue;
            }
        }
        else // pid == 0, no children have died
        {
            time_t now = time(NULL);
            if (now >= last30SecCheck + 30)
            {
                Log::debug("30-second check");
                last30SecCheck = now;

                std::unique_lock<std::mutex> sessionsLock(sessionsMutex);
                for (auto& it : sessions)
                {
                    if (it->lastMessageTime > it->idleSaveTime &&
                        it->lastMessageTime < now - 30)
                    {
                        // Trigger a .uno:Save
                        Log::info("Idle save triggered for session " + it->getId());

                        it->idleSaveTime = now;
                    }
                }
            }
            if (now >= lastFiveMinuteCheck + 300)
            {
                Log::debug("Five-minute check");
                lastFiveMinuteCheck = now;

                std::unique_lock<std::mutex> sessionsLock(sessionsMutex);
                for (auto& it : sessions)
                {
                    if (it->lastMessageTime >= it->idleSaveTime && 
                        it->lastMessageTime >= it->autoSaveTime)
                    {
                        // Trigger a .uno:Save
                        Log::info("Auto-save triggered for session " + it->getId());

                        it->autoSaveTime = now;
                    }
                }
            }

            sleep(MAINTENANCE_INTERVAL*2);
        }
    }

    if (LOOLWSD::DoTest)
        inputThread.join();

    // stop the service, no more request
    srv.stop();
    srv2.stop();

    // close all websockets
    threadPool.joinAll();

    // Terminate child processes
    Util::writeFIFO(LOOLWSD::BrokerWritePipe, "eof\r\n");
    Log::info("Requesting child process " + std::to_string(brokerPid) + " to terminate");
    Util::requestTermination(brokerPid);

    // wait broker process finish
    waitpid(brokerPid, &status, WUNTRACED);

    close(BrokerWritePipe);

    Log::info("Cleaning up childroot directory [" + ChildRoot + "].");
    std::vector<std::string> jails;
    File(ChildRoot).list(jails);
    for (auto& jail : jails)
    {
        const auto path = ChildRoot + jail;
        Log::info("Removing jail [" + path + "].");
        Util::removeFile(path, true);
    }

    Poco::Net::uninitializeSSL();
    Poco::Crypto::uninitializeCrypto();

    Log::info("Process [loolwsd] finished.");
    return Application::EXIT_OK;
}

POCO_SERVER_MAIN(LOOLWSD)

/* vim:set shiftwidth=4 softtabstop=4 expandtab: */
